#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>


int main1()
{
	// 符号的运算顺序
	int a = 2 + 6 / 3;
	int b = 2 + 3 + 4;
	printf("%d,%d\n", a, b);
	return 0;
}




int main2()
{
	/*12.1 隐式类型转换
C的整型算术运算总是至少以缺省整型类型的
精度来进行的。
为了获得这个精度，表达式中的字符和短
整型操作数在使用之前被转换为普通整型，
这种转换称为整型
提升。
整型提升的意义：
表达式的整型运算要在CPU的相应运算器
件内执行，CPU内整型运算器(ALU)的操
作数的字节长度
一般就是int的字节长度，同时也是CPU
的通用寄存器的长度。
因此，即使两个char类型的相加，在CP
U执行时实际上也要先转换为CPU内整型
操作数的标准长
度。
通用CPU（general-purpose CPU）是难
以直接实现两个8比特字节直接相加运算
（虽然机器指令
中可能有这种字节相加指令）。所以，
表达式中各种长度可能小于int长度的整
型值，都必须先转
换为int或unsigned int，然后才能送入
CPU去执行运算。*/
	char a = 5;
	char b = 126;
	char c = a + b;
	printf("%d\n", c);
	return 0;
}



int main3()
{
	/*//负数的整形提升
char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：
11111111111111111111111111111111
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000000000000000000000000001*/

//无符号整形提升，高位补0
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	return 0;
}










//实例2
int main4()
{
	char c = 1;
	printf("%u\n", sizeof(c));
	printf("%u\n", sizeof(+c));
	printf("%u\n", sizeof(-c));
	return 0;
}









/*12.2 算术转换
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运
算。
警告：
但是算术转换要合理，要不然会有一些潜在的问题。*/






/*12.3 操作符的属性
复杂表达式的求值有三个影响的因素。
1. 操作符的优先级
2. 操作符的结合性
3. 是否控制求值顺序。

两个相邻的操作符先执行哪个？
取决于他们的优先级。
如果两者的优先级相同，
取决于他们的结合性。*/






int fun()
{
	static int count = 1;
	return ++count;
}
int main5()
{
	int answer;
	answer = fun() - fun() * fun();
	printf("%d\n", answer);//输出多少？
	return 0;
}




